---
title: 物理削除でレコードが増えます。論理削除に潜む「暗黙の期待」のワナ
emoji: 🗞️
type: tech
topics:
  - database
  - SQL
  - 論理削除
published: false
---

# この記事について
この記事は論理削除に潜む罠について書いたものだったんだけど、書き上げたのちに検証のミスに気がついたのでお蔵入りにした。
具体的には、論理削除を導入した場合、LEFT JOINで絞り込み時に思わぬ挙動をすると書いているが、実際はWHERE句に書くのが問題であり、JOIN句に書けば問題ない。
もしこの記事を書くのなら以下のようなタイトル・構成にする。

- タイトル
	- 論理削除はWHEREで絞り込んではいけない
- 構成
	- これはなに
		- 記事の概要
	- どうすればいいか
		- WHEREじゃなくてJOINにかけ
		- 具体的なクエリの例
	- なんで？
		- WHEREにかくと予期せぬことが起きる
			- 例えば、子テーブルで論理削除レコードのみになった時、検索結果にレコードが出なくなる
			- こんな感じになる
				- 図
		- なんでそんなことが？
			- 絞り込みのタイミングが違う
			- 結合の前後どちらで絞られるかによって、LEFT JOINでレコードが残るかどうかが変わる
				- WHEREの評価順序がJOINよりもあと。JOINしたのち、絞り込まれると結合先ごと消えてしまう
				- JOINで絞った場合、JOINする前に絞れるのでLEFT JOINで親テーブルのレコードは残る
	- おわりに
		- 論理削除はJOINで絞るって半ば当たり前なんですが、理由までは分かってなかった人もいるのでは。WHEREで絞られた時にレビューで弾けるようにしておきましょう


---
# これはなに
こんにちは、レバテック開発部の森田です。
今回は物理削除したはずなのにレコードが増えるという事象^[な...何を言っているのかわからねーと思うが...。ちなみに記事のアイコンにした絵文字は新聞紙の束です。遠くから見るとポルナレフの頭に見えるから採用しました ]に直面したため、なんでそんなことが起きたのかを共有したいと思います。また、その背景には論理削除をめぐる勘違いが隠れていたため、こちらについても説明します。

:::details 構成
## 構成
以下の構成でいきます。

- なにが起きたのか？
- なんでそんなことが起きるのか？
- 論理削除のワナについて

最初に今回直面した出来事の説明、締めに論理削除の抱えるワナについて説明します。
:::

それでは参りましょう。

# なにが起きたのか？
まずは今回発生した事象について見ていきましょう。スキーマ・クエリの説明を以下に続けます。

## テーブル
![](https://storage.googleapis.com/zenn-user-upload/0a976cb73409-20251108.png)
テーブルの構成は上記のような形です。
１対多のシンプルなテーブルふたつで、一つのparentsレコードに複数のchildrenレコードが紐づきます。そして両テーブルともに論理削除のためのカラムを持ちます。
これらのテーブルを使って以下のようなクエリを流していました。

## クエリ

```sql
SELECT
    *
FROM
    parents
    LEFT JOIN children
        ON parents.id = children.parents_id
WHERE
    parents.deleted_at IS NULL
    AND cildren.deleted_at IS NULL
;
```
親子のテーブルをLEFT JOINし、論理削除されたレコードは除外しています^[なお、`deleted_at IS NULL`する位置はWHERE句ではなくJOIN句でも同様の結果となりました]。
論理削除を取り入れているスキーマであればこのようなクエリを書くことは日常茶飯事なのではないでしょうか？

## 論理削除されたレコードを物理削除すると、増える
このようななんの変哲もないスキーマ構成・クエリですが、問題を抱えています。
この状態で論理削除されたレコードを**物理削除すると、SELECT結果の行数が増えます。**


# なぜそんなことが起きるのか？
こういった挙動になる要因は２つあります。
ひとつ目は物理削除をする前は**論理削除カラムによって絞り込みが効いていた**ためです。そして二つ目は論理削除されたレコードが消えることでその絞り込みがなくなり、**LEFT JOINによってレコードが浮かび上がってくる**ためです。

言葉だけでは分かりにくいので、図を描いて見てみましょう。まずは以下が物理削除前のSELECT結果。
![](https://storage.googleapis.com/zenn-user-upload/82818c45a4af-20251108.png)
*濃紺網掛け部分は抽出対象外になったレコードだと思ってください*
シンプルにLEFT JOINし、`parents`, `children`テーブルそれぞれ`deleted_at`に値が入っていれば対象外としています。

次が物理削除後のSELECT結果です。
![](https://storage.googleapis.com/zenn-user-upload/eec493e190c9-20251108.png)
*赤文字は物理削除されたレコード。濃紺網掛けは抽出対象外です。*
論理削除されていたレコードをすべて物理削除すると、`deleted_at`での絞り込みが効かなくなり、レコードが浮かび上がってきます。

このように論理削除されたレコードが物理削除されることでSELECT結果が増えることがあります。
こう言った事象が発生するのは物理削除の扱いが難しいわけではなく、むしろ**論理削除に向けられる暗黙の期待**がクエリー結果の勘違いを引き起こしやすいために起きているのではないかと考えています。

# 論理削除のワナ
## 存在しないものとして振る舞うだろうという暗黙の期待
「論理削除に向けられる暗黙の期待」とは、**論理削除されたレコードは存在しないレコードとして振る舞ってくれるだろうという期待**です。
もう少し具体的なあるあるを示します。

例えばこの記事で紹介したクエリもそうなのですが、論理削除カラムを持つテーブルを使ったクエリを書くとき、ほとんどの場合は無条件で`deleted_at IS NULL`という条件を適用させます。
そういった条件を付け加えると、論理削除済みのレコードが一つでもある場合は抽出した結果から弾かれる、という挙動をします。ただ正直わたしはそのように動くことを期待しておらず、単に「論理削除されたレコードは存在していないものとする」という意味合いで`deleted_at IS NULL`を使っていました^[この期待通りの挙動をさせたいならJOINの前に論理削除済みレコードを弾かないといけない。ほかにもいい方法があるかも]。

このような思い込みは単にLEFT JOINの挙動を把握できていなかったからではなく、論理削除が登場する時に顕著に現れます。
例えば「合格した生徒が一人も履修していない教科を出す」というクエリを考える場合、全員が不合格である可能性は考慮しやすいと思います。ただ「生徒が一人も履修していない教科を出す（削除済みの生徒は考慮しない）」となったとたん、最初から誰も履修していないケースのみを考え、履修した生徒が全員削除済みであるケースが抜けやすくなります。

## 実際にあり得そうなパターン
そのほかにも論理削除が問題になりそうなケースを考えてみましょう。

例えば、商品テーブルと予約テーブルの関係性だとどうでしょうか。予約がない商品を抽出したいというニーズがあった時、商品テーブルと予約テーブルがJOINされてSELECTされるでしょう。しかしこのテーブルで予約が１件入ったのちに予約取り消しされた商品があったとします。かつ、具合が悪いことに予約取り消しが論理削除で実装されていた場合、この商品は予約が１件も入っていないのにもかかわらず抽出対象から外れてしまいます。

論理削除はユーザの誤って作成してしまったデータを削除する際や、データ保守運用の保険として使われることが多いと思います。
しかし本記事の説明したような観点でデータの信頼性を損ねる一因にもなってしまいます。

# おわりに
今回はわたしが仕事で直面して面白かったトラブルをお伝えしました。
論理削除と物理削除の対立はデータベース設計におけるかなり代表的な論点だと思います。利用するORMによっては論理削除が前提になっているものもあります。論理削除を導入している場合は、いま一度、ご自身のアプリケーションの発行するクエリを見直してみてください。

## 参考文献
- [論理削除とは何か？どのような解法があるのか？](https://fukabori.fm/episode/27)
    - t-wadaさん登場回。論理削除について語っています
    - このポッドキャストでは「本来別の表現をすべきカラムが論理削除で済まされてしまう」というようなデメリットを挙げています。以前まではそんな論理削除で済ませるようなことせんやろと思っていたのですが、今回の件をきっかけに論理削除が許されるユースケースが思ったより少ないのではと考えています
---
title: "５分で覚えるトランザクション分離レベル"
emoji: "🍽️"
type: "tech"
topics:
  - "mysql"
  - "トランザクション"
published: true
published_at: "2024-11-06 13:17"
publication_name: "levtech"
---

# これはなに

ども、レバテック開発部のもりたです。

今回はトランザクション分離レベルについてまとめました。トランザクション分離レベルって基本情報技術者試験とかで学ぶものの、座学だけだとあんまりピンとこずに忘れちゃいますよね。もりたも長らく曖昧な状態で生きていたのですが、よい理解の仕方があったので今回はその解説をします。

:::message alert
本記事には一部誤りが含まれます！
コメントにて本記事の誤りを指摘していただいているので、是非お読みください。

:::

# トランザクション分離レベルを構成するふたつの変数

## トランザクション分離レベルとは

まず初めに、概要を掴むところからいきましょう。

トランザクション分離レベルとは、あるトランザクションのデータベースに加えた変更が、他のトランザクションにどの程度影響を与えるか？　というもの（分離性、独立性）を一定基準でレベルに分けてまとめたものです。

どの程度影響を受けるか？　については三つの影響が定義され、その影響度合いに応じて分離レベルが４つ存在します。これは大体こんな図で解説されます。

![](https://storage.googleapis.com/zenn-user-upload/772593589481-20241015.png)
*よくある画像*

## コミット前後、処理内容の四象限

そして、この発生する影響は以下ふたつの要素の組み合わせです。

- コミットの前/後
    - コミットした前が見えるか、コミットした後が見えるか
- 更新処理/挿入削除処理
    - UPDATEの処理が見えるか、INSERT, DELETEの処理が見えるか

:::message alert
>更新処理/挿入削除処理

ここでは発生する影響をコントロールする要素として更新処理 or 挿入削除処理をあげていますが、この点が間違いです。より実態に近いのは**処理内容が見える** or **探索条件を満たしたデータが見える**になります。以降読み替えていただければ幸いです。

:::


図にすると、こんな感じです。
![](https://storage.googleapis.com/zenn-user-upload/fbb8cb2e6ebe-20241015.png)

今回はこの図を使って、ひとつひとつのトランザクション分離レベルの説明をします。よくこの図を覚えといてください。

# 四象限とトランザクション分離レベル

## 説明

さて、ここから個々のトランザクション分離レベルについて、具体的に説明します。先ほどの図に分離レベルを書き込んだものを先に示します。
![](https://storage.googleapis.com/zenn-user-upload/780f6048c472-20241015.png)

これが全てです。コミット前の処理が見える（ダーティリード）のがRead Uncommitedで、コミット後のUPDATEが見える（ファジーリード）のがRead Commited、コミット後のINSERT/DELETEが見える（ファントムリード）のがRepeatable Readです。また冒頭の図の通り、それぞれの分離レベルはより厳しいレベルで発生する影響を含みます。^[この箇所、[こばさんからのご指摘](https://x.com/tzkb/status/1854127472943734927)をいただきました。ありがとうございます！！]
なおSerializableが載っていませんが、どれも見えません。

## Read Uncommited
![](https://storage.googleapis.com/zenn-user-upload/7a37a342cd20-20241015.png)

コミット前のUPDATE/INSERT/DELETEが見えます。この不都合をダーティリードと呼びます。フォームから入力されて更新が確定していないデータのことをダーティと呼んだりするので馴染みはあるかなと思います。

他の解説記事だと更新が対象と書いてあることが多いのですが、トランザクション分離レベルが策定された[SQL92での定義](https://nyamage.github.io/post/2017/07/23/sql_92_isolation_level/)だと特に処理内容の言及はなく、INSERT/DELETEを含むようです。MySQLで実際に試しても、Read UncommitedでINSERTが確認できました。

## Read Commited
![](https://storage.googleapis.com/zenn-user-upload/d864a8d7c789-20241015.png)
コミット後のUPDATEが見えます。これをファジーリードだとか、ノンリピータブルリードと呼びます。

## Repeatable Read
![](https://storage.googleapis.com/zenn-user-upload/95350009ec3e-20241015.png)
コミット後のINSERT/DELETEが見えます。これをファントムリードと呼びます。

このトランザクション分離レベルがRepeatable Readなのは、一度読み込んだ対象行がもう一度読み込んでも同じ結果を返すため、リピート可能と言っています。

なお、MySQLのInnoDBではこの分離レベルがデフォルトです。かつ、ネクストキーロックという仕組みでファントムリードを防いでいます。

## Serializable
トランザクションが直列し、並行しない分離レベルです。並行しないので、同時実行した他のトランザクションの処理は見えません（というか存在しない）。この場合はファントムリードも発生しません。

# 最後に
以上で簡単な説明は終わりです。
簡単な説明でしたがトランザクション分離レベルと不都合を対応させやすくなっていたら幸いです。

## 参考文献
[SQL92](https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt)


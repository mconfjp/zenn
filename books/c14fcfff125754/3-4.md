---
title: "3-4. Customizing migrations（マイグレーションのカスタマイズ）"
---

# Customizing migrations（マイグレーションのカスタマイズ）

> **⚠️ 警告:**
> このガイドは **MongoDBには適用されません**。MongoDBでは `migrate dev` の代わりに `db push` が使用されます。

特定のシナリオでは、マイグレーションファイルを適用する**前に編集**する必要があります。

例えば、データ損失なしで 1対1リレーションの方向を変更する場合（外部キーを片側から反対側に移動する場合）には、**データ自体を移動する**必要があります。このSQLはデフォルトのマイグレーションには含まれていないため、**手動で記述**しなければなりません。

このガイドでは、マイグレーションファイルを編集する方法と、そのユースケースの例をいくつか説明します。

## 📝 マイグレーションファイルを編集する方法

適用する前にマイグレーションファイルを編集するための一般的な手順は以下の通りです。

1.  カスタムSQLを必要とするスキーマ変更を行う（例：既存のデータを保持するため）。
2.  以下のコマンドを使用して**ドラフトマイグレーションを作成**します。
    ```bash
    npx prisma migrate dev --create-only
    ```
3.  生成されたSQLファイルを**修正**します。
4.  以下のコマンドを実行して、修正されたSQLを**適用**します。
    ```bash
    npx prisma migrate dev
    ```

-----

## ✏️ 例: フィールドの名前変更

デフォルトでは、スキーマ内のフィールドの名前を変更すると、以下の操作を行うマイグレーションが生成されます。

  * 新しいカラムを作成する（例: `fullname`）。
  * 既存のカラム（例: `name`）と、そのカラム内のデータを**削除**する。

本番環境でマイグレーションを実行する際に**データ損失を防ぐ**ためには、実際にフィールドの名前を変更し、生成されたマイグレーションSQLを適用する前に修正する必要があります。

### 手順

1.  スキーマ内でフィールドの名前を変更します。（例: スペルミスの `biograpy` を `biography` に修正します。）

2.  以下のコマンドを実行して、編集可能なドラフトマイグレーションを作成します。

    ```bash
    npx prisma migrate dev --name rename-migration --create-only
    ```

3.  ドラフトマイグレーションを編集し、**`DROP / DELETE`（削除）を単一の `RENAME COLUMN`（カラム名変更）に変更**します。

    **【変更前】（生成されたSQL）**

    ```sql
    ALTER TABLE "Profile" DROP COLUMN "biograpy",
    ADD COLUMN "biography" TEXT NOT NULL;
    ```

    **【変更後】（修正後のSQL - PostgreSQL/MySQLなどの場合）**

    ```sql
    ALTER TABLE "Profile"
    RENAME COLUMN "biograpy" TO "biography";
    ```

    （SQL Serverの場合は、`ALTER TABLE RENAME COLUMN` の代わりにストアドプロシージャ `sp_rename` を使用します。）

4.  マイグレーションを保存し、適用します。

    ```bash
    npx prisma migrate dev
    ```

> **💡 ヒント:**
> 同じ手法を使用してモデルの名前を変更することもできます。生成されたSQLを編集し、テーブルを削除して再作成するのではなく、**テーブルの名前を変更**します。

-----

## 🚀 例: Expand and Contract パターンを使用してダウンタイムなしでスキーマを進化させる

既存のフィールドへのスキーマ変更（例：フィールド名の変更）は、**ダウンタイム**につながる可能性があります。これは、既存のフィールドを変更するマイグレーションの適用から、変更されたフィールドを使用する新しいバージョンのアプリケーションコードのデプロイまでの間に発生します。

このダウンタイムを防ぐために、**変更を段階的に導入する**ように設計された一連の個別のステップにフィールドの変更を分割することができます。このパターンは**Expand and Contract（展開と収縮）パターン**として知られています。

`bio` フィールドを `biography` に名前変更する場合の、PrismaでのExpand and Contractパターンは以下のようになります。

1.  **【Expand: スキーマ変更 1】** 新しい `biography` フィールドをPrismaスキーマに追加し、マイグレーションを作成します。

    ```prisma
    model Profile {
      id          Int     @id @default(autoincrement())
      bio         String  // 既存のフィールド
      biography   String  // ← 追加された新しいフィールド
      // ...
    }
    ```

2.  **【Expand: コード変更 1】** アプリケーションコードを更新し、**`bio` と `biography` の両方のフィールドに書き込み**ますが、引き続き **`bio` フィールドから読み取り**ます。そしてコードをデプロイします。

3.  **【Expand: データ移行】** **空のマイグレーション**を作成し、既存のデータを `bio` から `biography` フィールドにコピーします。

    ```bash
    npx prisma migrate dev --name copy_biography --create-only
    ```

    生成されたSQLを以下のように編集します。

    ```sql
    UPDATE "Profile" SET biography = bio;
    ```

    そして、マイグレーションを適用します。

4.  **【Expand: 検証】** データベースで `biography` フィールドの整合性を確認します。

5.  **【Contract: コード変更 2】** アプリケーションコードを更新し、**新しい `biography` フィールドから読み取る**ようにします。

6.  **【Contract: コード変更 3】** アプリケーションコードを更新し、**`bio` フィールドへの書き込みを停止**します。

7.  **【Contract: スキーマ変更 2】** Prismaスキーマから `bio` を削除し、`bio` フィールドを削除するためのマイグレーションを作成します。

    ```bash
    npx prisma migrate dev --name remove_bio
    ```

このアプローチを使用することで、アプリケーションコードで使用されている既存のフィールドを変更する際に起こりがちな潜在的なダウンタイムを回避し、マイグレーションの適用と更新されたアプリケーションコードのデプロイとの間の調整の必要性を減らすことができます。

-----

## ↔️ 例: 1対1リレーションの方向を変更する

1対1リレーションの方向を変更するには、以下の手順を実行します。

1.  **スキーマ内で変更を行う:**
    外部キーを `Profile` モデルから `User` モデルに移動するなど、リレーションの方向を変更します。

    ```prisma
    // 変更後のスキーマ例
    model User {
      // ...
      profile Profile? @relation(fields: [profileId], references: [id])
      profileId Int @unique // ← 外部キーがUser側に移動
    }
    model Profile {
      // ...
      user User // ← 外部キーを持たない
    }
    ```

2.  **編集可能なドラフトマイグレーションを作成する:**

    ```bash
    npx prisma migrate dev --name rename-migration --create-only
    ```

    **⚠️ 警告:** データ損失が発生する可能性があるというCLI結果が表示されます。

3.  **ドラフトマイグレーションを編集する:**
    生成されたSQLに、データを保持するための **`UPDATE` ステートメント**を手動で挿入します。

    **【変更前】（生成されたSQL - データ損失が発生する可能性あり）**
    （既存の外部キーを削除し、古いカラムを削除してから、新しいカラムを追加し、新しい外部キーを作成するSQLが含まれます。）

    **【変更後】（修正後のSQL - データ保持のため `UPDATE` を追加）**

    ```sql
    -- AlterTable (新しいprofileIdカラムを追加。最初はNULLを許可)
    ALTER TABLE "User" ADD COLUMN "profileId" INTEGER;

    -- データ移行: 既存のProfile.userIdの値を新しいUser.profileIdにコピー
    UPDATE "User"
    SET "profileId" = "Profile".id
    FROM "Profile"
    WHERE "User".id = "Profile"."userId";

    -- AlterTable (新しいprofileIdカラムをNOT NULLに設定)
    ALTER TABLE "User" ALTER COLUMN "profileId" SET NOT NULL;

    -- AlterTable (古いProfile.userIdカラムを削除)
    ALTER TABLE "Profile" DROP COLUMN "userId";

    -- CreateIndex (新しいユニークインデックスを作成)
    CREATE UNIQUE INDEX "User_profileId_unique" ON "User"("profileId");

    -- AddForeignKey (新しい外部キーを追加)
    ALTER TABLE "User" ADD FOREIGN KEY ("profileId") REFERENCES "Profile"("id") ON DELETE CASCADE ON UPDATE CASCADE;

    -- (その他、古い外部キーの削除などのSQLは適切に残す)
    ```

4.  **マイグレーションを保存し、適用します。**

    ```bash
    npx prisma migrate dev
    ```

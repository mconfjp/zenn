# よむ
https://readouble.com/laravel/8.x/ja/eloquent-relationships.html
そんな面白いところじゃないと思うので、雑にざっと読む。

## リレーションの定義
### １対１／１所有
- モデル名から外部キーは自動生成される
- hasOneの逆をbelongsToを使って表現。これって多でも？

### 子モデル上の親モデルの自動ハイドレート
- `Post::with('comments')->get();`した時に、`comments->post->title`ってやると、コメントからポストは取れないのでここでクエリが発行される
- `return $this->hasMany(Comment::class)->chaperone();`こうやって定義するとこれでEagerロードされる
	- 🐙

#### デフォルトモデル
- nullだったときに返すやつを定義できる
	- Nullオブジェクトパターン

### Has One of Many
```
/** * ユーザーの最も古い注文を取得 */ 
public function oldestOrder(): HasOne 
{ 
	return $this->hasOne(Order::class)->oldestOfMany(); 
}
```
- これだと一番古いやつが取れる。が、この時古いかどうかは主キーのIDで判断しているらしい。
	- カス

### "Many"リレーションをHas Oneリレーションへ変換する 
これは何が便利なんだ
なんか便利なんだろな
→hasManyしてるやつを継承できる

### Has Many Through
これも正直よくわからん。throughがあると嬉しいのってなんだ
中間のオブジェクトが取れちゃってめんどいデータになるのを防いでるらしい。なるほど。


# 感想
- 読んだ箇所
	- 叩いたリレーション
		- https://readouble.com/laravel/11.x/ja/eloquent-relationships.html#many-to-many
	- この直前まで読んだ
- 感想
	- 徐々にEloquentでクエリをかく面白さに気がついてきたかも
	- まず、めっちゃ長いんだよな、そんで、よくあるクエリのパターンに対して、アプリ側が使いやすいような状態で出すみたいなのをサポートしている
	- クエリそのままだと非効率なものがあり、そこへの知見が詰まっている間ンジがある


# 読む
https://readouble.com/laravel/11.x/ja/database.html

## イントロダクション
### 設定
- 対象のデータベースはconfig/database.phpに設定していく
	- sqliteもいける
	- sqlサーバーはパッケージが別で必要
- URLでも設定できる
- 読み書き別にできる
>`   sticky`オプションは、現在のリクエストサイクル中にデータベースへ書き込まれたレコードをすぐに読み取るため使用する**オプション**値です。`sticky`オプションが有効になっており、現在のリクエストサイクル中にデータベースへ対し「書き込み」操作が実行された場合、それ以降の「読み取り」操作では「書き込み」接続が使用されます。これにより、要求サイクル中に書き込まれたデータを、同じ要求中にデータベースからすぐに読み戻すことができます。これがアプリケーションにとって望ましい動作であるかどうかを判断するのは使用者の皆さん次第です。
- 同じ要求サイクル中にってどういう意味だろう
	- 🐙試すかなあ、まあ一旦調べるとかにしよう
## SQLクエリの実行
#### SELECT
> `DB`ファサードは、クエリのタイプごとに`select`、`update`、`insert`、`delete`、`statement`メソッドを提供します。
- なるほどね
- `$users = DB::select('select * from users where active = ?', [1]);`
	- きもい書き方だな〜〜
	- バインドはSQLインジェクションから保護されるらし
>`select`メソッドは常に結果の`配列`を返します。配列内の各結果は、データベースのレコードを表すPHPの`stdClass`オブジェクトになります。
- 🐙`stdClass`ってなんだ
	- 配列というのが知恵かも
#### スカラー値のセレクト
- スカラーが帰ってくる時はこうなるらし
```php
$burgers = DB::scalar( "select count(case when food = 'burger' then 1 end) as burgers from menu" );
```
- 🐙これ実装どうなってんの？　クエリそのまま受け取るんだからあんまりかく関数で違いなさそうに見える

#### 複数のクエリ結果セットのセレクト
```php
[$options, $notifications] = DB::selectResultSets(
    "CALL get_user_options_and_notifications(?)", $request->user()->id
);
```
- なるほどストアド使うのかー、あんま意識したことなかったが、あるか。けどなくねーそんなの使うか普通,
- ストアド使いたい理由が気になるわ
#### 名前付きバインディングの使用
`$results = DB::select('select * from users where id = :id', ['id' => 1]);
- オーケー

#### INSERT文の実行
`DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);`
- はい
	- まーそうね
#### UPDATE
```php
use Illuminate\Support\Facades\DB; $affected = DB::update( 'update users set votes = 100 where name = ?', ['Anita'] );
```
影響した行数を返す
#### DELETE
`$deleted = DB::delete('delete from users');`
影響した行数を返す

#### 一般的な文の実行
`DB::statement('drop table users');`
- 値を返さないものはこれらしい
	- DDLとか
#### プリペアドではない文の実行
`DB::unprepared('update users set votes = 100 where name = "Dries"');
- インジェクションには弱いらしい。なんで？　固定なのに？
	- 値のコントロールをさせるとだめ。まあそうか単純に文字列で入れてるだけだから、文字列を操作するコードを書いちゃうと死ぬのね

#### 暗黙のコミット
>トランザクション内で`DB`ファサードの`statement`および`unprepared`メソッドを使用する場合、[暗黙のコミット](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html)を引き起こすステートメントを回避するように注意する必要があります。これらのステートメントにより、データベースエンジンはトランザクション全体を間接的にコミットし、Laravelはデータベースのトランザクションレベルを認識しなくなります。このようなステートメントの例は、データベーステーブルの作成です。
- 🐙何を回避しろって言われてるのかわからない
	- 暗黙のコミットってDDLなら全てそうだと思うけど、Laravelがトランザクションレベルを認識しなくなるから、どう困るの？？？
	- あー、トランザクションをLaravel上で張ってた時に暗黙コミットされるとトランザクションが落ちるからねーってことか
	- それはMySQLでもよくある誤だな




# 読む
https://readouble.com/laravel/11.x/ja/eloquent.html

## モデルクラスの生成
- php artisan make:model Post
- オプションで一緒に作るファイルを指定できる
	- mマイグレーションファイル
	- fファクトリー
	- sシーダー
	- cコントローラー
	- rリソース
	- Rリクエスト
	- all
	- pivotピボット？
- modelの調査
	- model:showする
	- ホーン
	- これアプリケーション上のリレーションがわかるんか
## 規約
- どうやってテーブル名を指定するか、IDを指定するか、タイムスタンプを指定するかなど
	- どのテーブルにもあるからここで説明したんかな？？？
	- カラムの追加方法とか知りたいけどなここで
## DB接続
はい
## デフォルト属性値
はい
## 厳格さ
遅延ロードを防ぐかどうか
何それ
N+1的な動きをするコードらしい

# モデルの取得
- Model自身がテーブルを指定したクエリビルダーになっている
	- なるほどね
	- ラッパーなので、Laravelのクエリビルダーのメソッドを使える
# モデルのリフレッシュ
- DBから取得したModelのインスタンスでfresh, refreshすると、モデルを更新できる
- もう一度クエリしたりする
	- fresh, refreshの違いがわからんな🐙
## コレクション
> Eloquent `Collection`クラスはLaravelの基本`Illuminate\Support\Collection`クラスを拡張し、データコレクションを操作するために[さまざまな便利なメソッド](https://readouble.com/laravel/11.x/ja/collections.html#available-methods)を提供しています。たとえば、`reject`メソッドを使用して、呼び出されたクロージャの結果に基づいてコレクションからモデルを削除できます。
- ふーん
- Laravelのコレクション + 便利メソッド
## 結果の分割(chunk)
- allとかで一気に撮ると重たいから、chunkで細かくとれる
	- chunkの単位で撮ってきて、クロージャの処理をしていく。allと同じく全量撮るけど、一気にはやらないからメモリの負荷を減らせる
	- chunkById危険そう

## レイジーコレクション(lazy)
>`lazy`メソッドは、裏でチャンク単位でクエリを実行するという意味で、[`chunk`メソッド](https://readouble.com/laravel/11.x/ja/eloquent.html#chunking-results)と同様に動作します。しかし、`lazy`メソッドは、各チャンクをそのままコールバックへ渡すのではなく、フラット化したEloquentモデルの[`LazyCollection`](https://readouble.com/laravel/11.x/ja/collections.html#lazy-collections)を返すので、結果を単一のストリームとして操作できます。
- sqlのコストとしては分けた方がでかい気がするんだけど、なんでそんなことするんだ
- かつ、アプリケーションのメモリ消費量も分割されないよな？
- 利用する側の詳しい記事
	- https://qiita.com/fuwasegu/items/c7758da9a2b310ceaf61
	- 配列処理とかのこまけ〜話が載ってる
- lazycollectionが便利なのはGeneratorのことがわかってないとだめ
	- https://zenn.dev/haradakunihiko/articles/430dd707fbba42
	- これ良い記事だった
- まあとにかく、大量データ処理におけるアプリケーションメモリ負荷の観点でこういう機能が必要なのだな
	- これ現代でもおなじ？　それともメモリ容量あがってるから気にしない？

## カーソル
- 単一モデルをデータベースからいちどとってきて、遅延読み込みするらしい。
	- これはいいよな
	- けどリレーションはとれないと。リレーションとりたいならlazyつかってと
- 

# サブクエリ

# 単一モデル取得
- これはコレクションじゃなくてモデルインスタンスを返すらしい
	- コレクションとモデルインスタンスの構造的な違いを知りたい
## NotFound例外
- FindOrFail
	- これなんでわざわざ例外にするんだという疑問が常にあった
	- 例外か？　単にそういうケースもあるだけだろ
		- キャッチしなかったら自動で404になるのか
		- なんかそれはちょっと変な気もするが、、
- 
## モデルの取得／生成
- `firstOrCreate`, `firstOrNew`
	- createは作成する
	- newはインスタンスを作る
## 集計の取得
- これはモデルでもコレクションでもなくスカラを返す

# モデルの挿入と更新
## 挿入
- モデルをインスタンス化してsaveするだけ
- createでもいけるけど、これやる前にfillable, guardedを設定する必要がある。複数代入の脆弱性から守るためにやる
>複数代入の脆弱性は、ユーザーから予期していないHTTPリクエストフィールドを渡され、そのフィールドがデータベース内の予想外のカラムを変更する場合に発生します。たとえば、悪意のあるユーザーがHTTPリクエストを介して`is_admin`パラメータを送信し、それがモデルの`create`メソッドに渡されて、ユーザーが自分自身を管理者に格上げする場合が考えられます。
- なるほどね。configファイル狙いでアクセスしかけるみたいなやつか

## 更新
- インスタンスを取得して、値をプロパティに入れて、save
- updateOrCreate()でなければ作るになる
## 複数更新
- 一括更新ができる
```
Flight::where('active', 1)
	->where('destination', 'Tokyo')
	->update(['delayed' => 1]);
```
- これの注意点はモデルイベントが発火しないこと。モデルを取得してないかららしい。これ怖すぎるな...
## 属性の変更の判断
- Dirtyを見るやつだ
	- `isDirty`, `isClean`, `wasChanged`メソッドがある
	- isDirty, モデルインスタンスを取得した後に、変更が入っているかを見てる
		- だから、保存前じゃないと意味がない
	- isClean, 綺麗かどうか
	- wasChanged, 変更されたか。isDirtyの保存後バージョンか
- getOriginal
	- save前に、インスタンスの素の状態を取得する
		- これあるってことはmodelの構造にはoriginalとdirtyがあるってことかな
## 複数代入
- 保存時に複数のカラムに対して配列で渡して保存するやつ
	- guard, fillableが必要
- fillで複数カラムの配列を渡せる
## 一括割り当てとJSONカラム
- JSONカラムへ代入するときは、fillable指定しないとだめ
	- 単独でもってこと？？？
- fuarded対象だったら、ネストしたJSONは代入させない
## 複数代入の許可
- 全ての属性を一括割り当て可能にしたいなら、guardedをからの配列で指定する
## 複数代入例外
- 複数代入操作をするとき、fillableで指定されてない属性は黙って捨てられる
	- ローカル開発時はこれが混乱の元になりがち
	- `preventSilentlyDiscardingAttributes`メソッドをAppServiceProviderのbootで指定すると、例外投げるようになる
		- なるほどなあ
## 更新/挿入
- `upsert`でできる
	- updateOrCreateと違うのは、なかったら作るのは同じなんだけど、まあ変数の渡し方が違うなあ、じゃあ別に片方でいいだろ

# モデルの削除
- deleteでやる

## 主キーによる既存のモデルの削除
- deleteはモデルを一度取得してから削除する
- destroyだと、主キーがあれば取得せずに削除できる
	- これ何が嬉しいんだろう、まあちょっと早いし負荷もないが
>  `destroy`メソッドは各モデルを個別にロードし、`delete`メソッドを呼び出して、`deleting`イベントと`deleted`イベントが各モデルに適切にディスパッチされるようにします。
- ありがと、けどそれやったら取得してるんじゃないの？

## クエリを利用したモデルの削除
- モデルでクエリ発行して選択してからdeleteできるって話
## ソフトデリート
- deleted_atつけるだけ
	- trashedでソフトデリートされてるかどうかわかる
## 復元
- restoreで戻せる
- 複数もできるけど、これもモデルイベントを呼ばない
	- これ複数レコード処理したい時にイベント呼ぶようにするのってどうやるんだ🐙
## モデルの完全な削除
- forceDeleteで物理削除できる

# ソフトデリート済みモデルのクエリ
## ソフトデリートしたモデルの含め方
- `Flight::withTrashed()->where()...`みたいにすると含められる
	- リレーション先のモデルにもつけられる
- onlyTrashedで削除ずみのみ

# モデルの整理
- 定期的にレコードを削除したいモデルの対応
>不要になったモデルを定期的に削除したい場合があります。これを実現するには、定期的に整理したいモデルに、`Illuminate\Database\Eloquent\Prunable`か`Illuminate\Database\Eloquent\MassPrunable`トレイトを追加してください
- ふーん
- そんでroutes/console.phpでmodel:pruneをスケジュールするらしい

## 複数整理
- 一気に複数のレコードを整理するとき。モデルイベントは例によって発動しない

# モデルの複製
- replicateメソッドで複製できる
	- ちょっと修正したいときはfillしてあげる
	- 複製対象から外したいやつはreplicate([''excol_1, 'excol_2'])とする
# クエリスコープ
- Eloquentを使って生成したクエリ全てになんかくっつけるとかそういうことができるやつ
## グローバルスコープ
ソフトデリートはグローバルでやってる

### スコープの生成
`php artisan make:scope AncientScope`で`app/models/scopes`にファイルが作られる
まあなんかして作るんや
### スコープの適用
- モデルにScopedByアトリビューとを指定する
```php
<?php namespace App\Models; use App\Models\Scopes\AncientScope; use Illuminate\Database\Eloquent\Attributes\ScopedBy; #[ScopedBy([AncientScope::class])] 
class User extends Model 
{ 
// 
}
```
### スコープを対象外にする
`User::withoutGlobalScope( AncientScope: :class)->get();`こういう感じにやる

## ローカルスコープ
### 作り方
モデルクラスの中にメソッドとして作る
scopePopularみたいなメソッド名にする
### 適用
`$users = User::popular()->active()->orderBy('created_at')->get();`使う時に、使う

## 動的スコープ

もある

# モデルの比較
>２つのモデルに同じ主キー、テーブル、およびデータベース接続があるかどうかを手早く検証するため
- に、is, isNotがあるらしい
- ホーン
# イベント
色々ある
- retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, trashed, frceDeleting, forceDeleted, restoring, restored, replicating
- 登録方法、オブザーバなど

# おわり
終わった。ふーん

- 感想
	- 論点
		- lazyCollectionとかのアプリケーションレイヤーのメモリ問題は面白い課題だと思った
		- あとはCRUD
			- ここにもなんかベストプラクティスが反映されてないかな
		- 定期的なレコード削除
		- 論理削除
		- クエリを使い回すためのスコープの概念
		- イベント
	- こんな感じの論点
		- まあ、普通だな



# これはなに
permanentノート候補一覧（ORM以前スコープ）

書籍セクション0「ORM以前（Embedded SQL / ODBC）」に対応するpermanentノート候補。
スコープ：`2026.2.22_雑書き_歴史_ORM_ORM以前.md` に記載の範囲。
参照：`2026.2.26_permanent候補一覧.md`（書籍全体版）

---

# 一覧

## 引き継ぎ候補（2026.2.26版より）

### ① SQL Access GroupとCLIによる標準化の試み（1989年）

**コアアイデア**
DBへの接続方法を標準化しようとした試みが1980年代末にあった。ただし「接続方法」の標準化であり、オブジェクトとテーブルの変換はしなかった。

**ネタ**
- Call Level Interface (CLI)：1980年代後半に登場。アプリがDBドライバを直接呼ぶのではなく、共通インターフェース経由で呼ぶ方式
- ODBC（Open Database Connectivity）：1992年にMicrosoftが標準化。CLIの考え方を実装した
- SQL Access Group：標準化を推進した業界団体（詳細調査が必要）
- Embedded SQLとの違い：Embedded SQLはソースコードにSQL直書き。CLIは実行時にSQL文字列を渡す

**参照元資料**
- `zettel/2_permanents/ORMに先行するDB抽象化は存在する.md`（スタブ状態、この候補で内容を肉付けする）
- `zenn/projects/ORMの書籍/4_技術書典20/2026.2.22_雑書き_歴史_ORM_ORM以前.md`

**既存permanentへのリンク候補**
- `[[ORMに先行するDB抽象化は存在する]]`（既存ノートを拡充するか、独立させるか検討）

**要調査**
- SQL Access Groupの正確な設立年・活動内容
- CLIがODBC仕様にどう繋がったか
- ベンダー固有APIの乱立がいかに辛かったか（Oracle OCI、DB2 CLI等の違い）

---

### ③ 4GL（第4世代言語）というアプローチ

**コアアイデア**
ORMとは別の方向から「データとロジックの分離」を解こうとした試みが4GLだった。DBと密結合した業務アプリ開発に特化していたが、OOP時代に合わなくなった。

**ネタ**
- 4GL（Fourth-Generation Language）：1980年代に登場
- 代表例：Oracle Forms、PowerBuilder、Progress4GL、Informix 4GL
- 特徴：スキーマを定義するとUIやCRUDが自動生成される。SQL+画面遷移を一体化
- 限界：複雑なビジネスロジック、OOPのオブジェクトグラフとの相性が悪い
- ORMとの関係：「DBとの統合」という課題を違う方向で解こうとした競合アプローチ

**参照元資料**
- 調査資料には直接言及なし（要調査）

**既存permanentへのリンク候補**
- `[[ORMに先行するDB抽象化は存在する]]`

**要調査**
- 4GLが衰退した具体的な理由（OOP普及との時系列）
- PowerBuilderは今も使われているか（2000年代以降の消長）
- 4GLとORMが同時代に競合していた時期はあったか

---

### ⑰ Embedded SQL → CLI → ODBCの3段階の進化

**コアアイデア**
DB接続の抽象化は3段階で進化した。それぞれが「前の方式の何が辛かったか」への回答になっている。

**ネタ**
- Embedded SQL（1970年代後半）：ソースコードにSQL直書き。プリコンパイラが必要。DBスキーマへの依存が強い
- CLI（1980年代後半）：実行時に関数でSQLを渡す。プリコンパイル不要。ただしDBベンダーごとに関数名・呼び出し方が違った（OracleはOCI、DB2はDB2 CLIなど）
- ODBC（1992年）：CLIの発想をMicrosoftが標準化。`SQLConnect()` `SQLExecDirect()` などどのDBでも同じAPIで呼べる。裏でDriverがDB差異を吸収

**参照元資料**
- [SP 96: SQL Access Group's Call-Level Interface（Dr. Dobb's, 1996）](https://jacobfilipp.com/DrDobbs/articles/DDJ/1996/9613/9613a/9613a.htm)
- [SQL Access Group - Wikipedia](https://en.wikipedia.org/wiki/SQL_Access_Group)

**既存permanentへのリンク候補**
- `[[ORMに先行するDB抽象化は存在する]]`

**要調査**
- CLI時代のコード例（OracleのOCIとDB2 CLIの具体的な差）
- ODBC以前にベンダー固有APIを使っていたときの実務上の苦労（体験談などあると良い）

---

### ⑱ 接続の標準化（ODBC）はORMの必要条件だったのか？

**コアアイデア**
ODBCなしにORMを作ると、DB製品ごとに接続ドライバを自前でメンテしないといけない。ODBCの登場（1992年）とTopLink for Smalltalk（1994年）の時系列は偶然ではないかもしれない。

**ネタ**
- ODBC登場：1992年
- TopLink for Smalltalk：1994年
- 現代の類比：TerraformはクラウドプロバイダごとにProviderを自前でメンテしている
- 仮説：標準化がなければORMはDB製品ごとの対応コストが高すぎて普及しなかった

**参照元資料**
- なし（仮説ベース）

**既存permanentへのリンク候補**
- `[[ORMに先行するDB抽象化は存在する]]`
- `[[主要ORMの歴史]]`

**要調査**
- EOF・ObjectLensの接続実装はどうなっていたか（ODBC以前に存在したはず）
- TopLink for SmalltalkはODBCを使っていたのか、独自実装だったのか

---

## WIPノート補完候補

### W1. 1980年代にORMが生まれなかった技術的・文化的背景

**現状**
`WIP_1980年代には現代のORMほどのデータベース抽象化は行われなかったが、それは技術的文化的な背景があった.md` として存在するがWIP状態。「なに」が空欄のまま。

**コアアイデア**（案）
1980年代にORMに相当するものが生まれなかったのは、技術的限界だけでなく、メインフレーム文化・手続き型言語・ハードウェア制約という複合的な背景があったから。

**ネタ（WIPノートにあり）**
- Oracle 2商用リリース（1979年）、IBM DB2リリース（1982年）
- Smalltalk-80（1980年）、C++（1983年）とOOP普及の時系列
- COBOL中心の開発文化：データとロジックの分離という概念が薄かった
- メインフレーム時代の開発哲学：「魔法的な動作より明示的な制御」
- 技術的要因：複雑な抽象化レイヤーを実装する言語機能の不足、リソース制約

**参照元資料**
- `zettel/2_permanents/WIP_1980年代には現代のORMほどのデータベース抽象化は行われなかったが、それは技術的文化的な背景があった.md`

**作業内容**
「なに」セクションを書いてWIPを完成させる。独立したpermanentとして成立する内容がすでに揃っている。

---

## 新規候補

### N1. JDBC以前の手書きマッピング期 - OOPとRDBが出会った1990年代の実務

**コアアイデア**
RDB（1979年〜）とOOP言語（1980年代〜）が普及してから、ORMが登場する1994年まで十数年の空白がある。その間、開発者はJDBCやODBCを直接叩き、SQL結果をオブジェクトに手で変換していた。この辛さがORMを必要とさせた。

**ネタ**
- JDBC（Java Database Connectivity）：JDBCで発行されるSQLはコード中にハードコードされるか実行時に生成される（Hibernateインアクション 1.1.3）
- 開発者がSQL結果をオブジェクトに変換するコードを毎回手書きしていた
- 変換コードは繰り返しパターン（接続、クエリ実行、ResultSet読み取り、オブジェクト生成）
- 「更新・挿入・削除を書かないといけない」というJDBC APIの辛さ（Hibernateインアクション 1.2.6）
- この繰り返しの辛さを解消するために、まず手動ユーティリティが生まれ、やがてORMになった

**参照元資料**
- `zettel/1_literatures/『Hibernateインアクション』/『Hibernateインアクション』_第1章_オブジェクト・リレーショナル永続化の基礎.md`

**既存permanentへのリンク候補**
- `[[ORMに先行するDB抽象化は存在する]]`

**要調査**
- JDBC登場前後の具体的な手書きマッピングコード例
- 1990年代初頭に「変換コードジェネレーター」のようなツールが生まれていたか

---

## 調査優先度まとめ

| 候補 | 優先度 | 理由 |
|------|--------|------|
| ⑰ Embedded SQL→CLI→ODBCの3段階 | ★★★ | 本文の核。ORM以前の主役 |
| W1. WIPノート補完 | ★★★ | すでに内容があるのに未完成。コスパが高い |
| ① CLI/ODBC標準化の試み | ★★ | ⑰と重なる部分があるが、SQL Access Groupの史実を詰める価値あり |
| N1. JDBC手書きマッピング期 | ★★ | 「なぜORMが必要だったか」を説明するのに有効 |
| ③ 4GL | ★ | 脱線リスクあり。スペースがあれば |
| ⑱ ODBCはORMの必要条件か | ★ | 仮説ベース。要調査事項が多い |

## ORMの概観

### ORMとはなにか

ORMとは、Object-Relational Mapperの略称である。日本語では「ORマッパー」と呼ばれることも多い。

その名前が示すとおり、ORMは **Object（オブジェクト）** と **Relational（リレーショナル）** のあいだを **Mapping（対応づけ）** するものだ。もう少し具体的に言えば、オブジェクト指向プログラミング言語で書かれたアプリケーションと、リレーショナルデータベース（RDB）とのあいだのやりとりを仲介するソフトウェアである。

Web開発を始めたばかりの人にとって、ORMは「SQLを書かなくてもデータベースを操作できる便利なやつ」くらいの認識かもしれない。実際、多くの入門書やチュートリアルでは、ORMはそのように紹介される。フレームワークの一部として当たり前のように組み込まれているため、その存在を深く意識しないまま使っている開発者も少なくないだろう。

しかし、ORMが「便利なやつ」として存在しているのには理由がある。その背景には、オブジェクト指向プログラミングとリレーショナルデータベースという、根本的に異なるふたつのパラダイムを橋渡しするという、想像以上に難しい課題がある。本章では、この課題を概観し、ORMが何を目指してきたのかを整理する。

### ORMの主な役割——インピーダンスミスマッチの解消

#### オブジェクトとリレーショナルモデルの「ずれ」

ORMが解決しようとしている中核的な課題は、**インピーダンスミスマッチ**（impedance mismatch）と呼ばれる問題である。

「インピーダンス」という言葉は、元々は電気電子分野の用語だ。19世紀末に生まれた概念で、交流回路における電流の流れにくさを表す。回路Aの出力と回路Bの入力を接続するとき、双方のインピーダンスに差が少ないほど効率よく電力を受け渡しできる。逆に、この差が大きいと損失が生じる。

ソフトウェアの世界でこの言葉が使われるとき、意味するのは **オブジェクト指向の世界とリレーショナルモデルの世界のあいだに存在する、構造的な不一致** のことだ。

この不一致は、具体的にはいくつかの問題として現れる。代表的なものを挙げよう。

**粒度の問題。** オブジェクトはデータの粒度を自由に変えられる。たとえば「住所」を都道府県・市区町村・番地といった任意の単位で分割して扱うことができる。一方、RDBではテーブルのカラム構造として粒度が固定されるため、同じような柔軟性を持つことが難しい。

**サブタイプの問題。** オブジェクト指向では継承やポリモーフィズムは基本的な機能だ。しかし、リレーショナルモデルにはIS-A関係を直接表現する仕組みがない。テーブルの継承をどう表現するかについてはいくつかのアプローチが提案されてきたが（クラスごとのテーブル、具象クラスごとのテーブル、クラスファミリーごとのテーブルなど）、いずれも一長一短であり、決定的な解法は存在しない。

**オブジェクト同一性の問題。** RDBではサロゲートキー（自動採番の整数値など）によってレコードを一意に識別するのが一般的だ。オブジェクト指向の世界では、オブジェクトの同一性はメモリ上の位置によって暗黙的に決まる——同じ状態を持つふたつのオブジェクトでも、別々のメモリに存在すれば別のオブジェクトだ。この「何をもって同一とするか」の定義が、ふたつの世界で根本的に異なっている。

#### そもそも、なぜふたつのモデルが必要なのか

ここで素朴な疑問が浮かぶかもしれない。そもそも、なぜオブジェクトのモデルとリレーショナルのモデル、ふたつのデータモデルが並存する必要があるのだろうか。どちらかに統一すればいいのではないか。

実は、両者にはそれぞれ異なる役割がある。

**永続化層のデータモデル**は、データを安定的に蓄積するためのものだ。リレーショナルモデルで表現され、あまり変化しない。データベースのスキーマは一度定義されると、そう頻繁には変わらない。

**アプリケーション層のデータモデル**は、特定のユースケースに応じてデータを扱うためのものだ。オブジェクトとして表現され、アプリケーションの要件に応じて頻繁に変化する。

重要なのは、オブジェクトが表現するのは **特定のユースケースにおけるデータの断面** だということだ。ある画面では顧客の名前と注文履歴が必要で、別の画面では顧客の住所と支払い情報が必要になる。オブジェクトはそのつど必要な形にデータを整形する。そのオブジェクトの形をそのままテーブル構造にしようとすると、かえって使い勝手が悪くなる。アプリケーションの要件が変わるたびにテーブル構造を変えるわけにはいかないからだ。

つまり、この二層構造は「しかたない」のではなく、それぞれの層が果たすべき役割が違うがゆえに、必然的に生まれるものなのだ。そしてこのふたつの層のあいだに立って翻訳を行うのが、ORMの仕事である。

#### 「コンピュータ科学のベトナム戦争」

インピーダンスミスマッチの解消を目指して生まれたORM。しかし、その道のりは平坦ではなかった。

2006年、Ted Newardは「The Vietnam of Computer Science」と題した論文で、ORMを **「コンピュータ科学のベトナム戦争」** と表現した（Ted Neward, "The Vietnam of Computer Science", 2006, http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx ）。ベトナム戦争が「最初はうまくいくと思ったが、やがて泥沼化した」紛争であったように、ORMもまた同じ構造を持つ——最初は順調に見えるが、時間とともに複雑さが増し、明確な勝利条件も撤退条件もない泥沼に利用者を引きずり込む、というのだ。

Newardが指摘したORMの問題は、主に以下のようなものだった。

- **簡単なケースでは便利だが、複雑になると破綻する。** テーブルとクラスを1対1で対応づけているうちは問題ない。しかし、継承・関連・複雑なクエリが絡み始めると、マッピングの複雑さが急激に増大する。
- **パフォーマンス問題。** 典型的なのがN+1問題だ。関連するオブジェクトを取得するためにN回の追加クエリが発生し、パフォーマンスが劇的に悪化する。遅延ロードと一括ロードのどちらを選んでも、常に「ちょうどいい」タイミングはない。
- **抽象化の漏れ（Leaky Abstraction）。** ORMはSQLを抽象化しているが、パフォーマンスチューニングや複雑なクエリでは結局SQLの知識が必要になる。抽象化の裏側が透けて見えてしまう。
- **収穫逓減の法則。** 初期の成功が特定の方針へのコミットメントを生み、さらなる投資がますます割に合わない結果をもたらす。Newardはこれを「滑りやすい坂道（Slippery Slope）」と呼んだ。

これは厳しい指摘だ。しかし注目すべきは、この論文が書かれた2006年から20年が経った現在も、 **ORMは現役で使われ続けている** ということだ。

Newardの指摘は的確だったが、開発者たちはその問題を承知のうえで、現実的な妥協点を模索してきた。ORMの限界を受け入れつつ、問題の80%を解決する道具として使い、残りの20%は生のSQLで対処する——Neward自身も論文の中で、このような「制限を受け入れた上での活用」を解決策のひとつとして提示している。

本書が扱うのは、まさにこの **「完璧ではないが、それでも生き残ってきた道具」** としてのORMの姿だ。ORMがどんな課題に直面し、どのような戦略でそれに対処してきたのかを、ここから先の章で詳しく見ていく。

### ふたつの流派——Active RecordとData Mapper

ORMには、大きく分けてふたつの設計パターンが存在する。Martin Fowlerが『Patterns of Enterprise Application Architecture』（2002）で整理した **Active Record** パターンと **Data Mapper** パターンだ。現代のほぼすべてのORMは、このどちらか（あるいはその変種）に分類できる。

#### Active Recordパターン

Active Recordパターンでは、**オブジェクトそのものがデータベースとのやりとりの責任を持つ。** ひとつのオブジェクトがひとつのテーブルの行に対応し、そのオブジェクトに`save()`や`delete()`といったメソッドが直接生えている。

```ruby
# Ruby on Rails の Active Record の例
user = User.new(name: "田中太郎", email: "tanaka@example.com")
user.save  # オブジェクト自身がINSERTを発行する

user.name = "田中次郎"
user.save  # オブジェクト自身がUPDATEを発行する
```

このパターンの特徴は、シンプルさと直感性にある。テーブルとオブジェクトが1対1で対応し、CRUDの操作がオブジェクトのメソッドとして表現される。テーブル構造がそのままクラスの構造になるため、学習コストが低い。

代表的な実装としては、Ruby on RailsのActiveRecordや、PHPのEloquent（Laravel）が挙げられる。いずれもフルスタックフレームワークの一部として提供されており、「規約に従えば設定不要（Convention over Configuration）」という思想と相性がよい。

一方で、オブジェクトがデータアクセスの責任まで持つことで、**ビジネスロジックとデータアクセスロジックが密結合になりやすい** という課題がある。アプリケーションが成長するにつれて、この密結合が複雑さの原因になることがある。

#### Data Mapperパターン

Data Mapperパターンでは、**オブジェクトとデータベースのあいだに独立したマッピング層を設ける。** オブジェクト自身はデータベースの存在を知らず、マッパーが両者の橋渡しをする。

```java
// Hibernateの例（Data Mapperパターン）
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

User user = new User("田中太郎", "tanaka@example.com");
session.save(user);  // マッパーがINSERTを発行する

tx.commit();
session.close();
```

このパターンの特徴は、ドメインオブジェクトの独立性にある。オブジェクトは純粋にビジネスロジックの表現に徹し、永続化の方法を知る必要がない。テスト時にデータベースなしで動作確認できるなど、関心の分離がもたらす利点が大きい。

代表的な実装としては、JavaのHibernate、TypeScriptのPrismaやDrizzleなどが挙げられる。Hibernateは2001年に登場した、OSSとしては初期のORM実装のひとつであり、ORMの分野におけるData Mapperパターンの代名詞的存在だ。当初エンタープライズ向けの商用製品として存在していたTopLink（1994年にSmalltalk向け、1996年にJava向けに登場）がライセンス料金を必要としていたのに対し、Hibernateは「Professional Open Source」として無償で利用できた点が、2000年代のORM普及に大きく貢献した。

一方で、マッピング層の設定や管理が必要になるため、Active Recordパターンに比べて **初期の導入コストが高くなりがち** だ。単純なCRUDアプリケーションでは、この追加の複雑さが過剰に感じられることもある。

#### どちらが優れているのか？

結論から言えば、どちらが一方的に優れているということはない。

Active Recordパターンは、テーブル構造とオブジェクト構造が近い場合に力を発揮する。素早くプロトタイプを作りたい場合や、CRUDが中心のアプリケーションに適している。

Data Mapperパターンは、ドメインロジックが複雑で、オブジェクトの構造とテーブルの構造が乖離しやすいケースに向いている。長期的な保守性や、大規模なアプリケーションでの柔軟性を重視する場合に選ばれることが多い。

ここで思い出してほしいのは、先ほど触れた「ふたつのデータモデル」の話だ。永続化層のモデルとアプリケーション層のモデルは、それぞれ異なる役割を持つ。Active Recordパターンはこのふたつの距離を近く保つ設計であり、Data Mapperパターンはふたつの距離を遠くても許容する設計だと言える。どちらを選ぶかは、アプリケーションの性質に依存する。

---

ここまでで、ORMとは何か、どんな課題に向き合っているのか、そしてどのような設計の流派があるのか——概観を押さえた。

次章以降では、ORMが具体的にどんな仕組みでインピーダンスミスマッチに対処しているのかを、コードレベルで掘り下げていく。
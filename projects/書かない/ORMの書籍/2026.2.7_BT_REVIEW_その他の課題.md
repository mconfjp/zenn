## 現代からみた包括的な課題

前章ではコンピュータ科学とアメリカ産業史を振り返りながら、永続化レイヤーの抽象化がどのように発展してきたのかを見てきました。Embedded SQLからODBC、そしてORMへ——歴史の中で課題が生まれ、それに応えるかたちで技術が進化してきたことがわかります。

この章では視点を現代に移し、永続化レイヤーの抽象化にまつわる課題を包括的に整理します。歴史の中で登場した課題に加え、現代のアプリケーション開発で日常的に直面する課題も含めて、全体像を俯瞰しましょう。

課題の整理にあたっては、2つの視点を使います。

1. **アプリケーションからデータベースへの処理の流れ**で見る課題
2. **開発工程**のなかで見る課題

そして最後に、ORMが抱える最大の構造的問題である**インピーダンスミスマッチ**を扱います。

### アプリケーションからデータベースへの流れで見る課題

まずは処理の流れに沿って見ていきましょう。アプリケーションがデータベースとやりとりするとき、大まかに次のステップを踏みます。

1. データベースに**接続**する
2. **クエリを生成**してデータベースに送る
3. 結果を受け取り、**オブジェクトに変換**する
4. アプリケーション側でそのオブジェクトを**処理**する

このそれぞれのステップに、固有の課題があります。

#### コネクション

アプリケーションがデータベースを使うには、まずコネクション（接続）を確立する必要があります。コネクションの確立にはTCPハンドシェイクや認証といったプロセスが含まれるため、そもそもコストのかかる操作です。

Webアプリケーションのようにリクエストごとにデータベースアクセスが発生する場合、毎回コネクションを確立・破棄していてはパフォーマンスが劣化します。そこで一般的に使われるのが**コネクションプーリング**です。あらかじめ一定数のコネクションを確立しておき、必要に応じて使い回す仕組みです。

コネクションプーリングは一見シンプルですが、考慮すべきことが多くあります。プールサイズをいくつにするか。アイドル状態のコネクションをいつ切断するか。コネクションが切れていた場合のリカバリをどうするか。トランザクション中のコネクションをどう管理するか——こうした問題に対して、多くのORMやデータベースドライバがプーリング機能を提供しています。

#### クエリの生成

コネクションが確立されたら、次はクエリを生成してデータベースに送信します。クエリの生成は、ORMが担う最も基本的な責務のひとつです。しかし「ただSQLを組み立てればいい」という単純な話ではありません。

**基本的なクエリ生成**

最も基本的なレベルでは、アプリケーション側の操作をSQLに変換する必要があります。たとえば「IDが1のユーザーを取得する」という操作を`SELECT * FROM users WHERE id = 1`に変換する、といった処理です。ORMのレベル分類[^orm-level]でいえば、レベル1（低レベルAPI）からレベル5（テーブルとオブジェクトのマッピング）まで、この基本的な変換をどこまで自動化するかに大きな幅があります。

[^orm-level]: ORMは抽象度によって5段階に分類できる。レベル1の低レベルAPI（ODBCに近いもの）からレベル5のテーブル-オブジェクトマッピング（Hibernateなど）まで。レベルが上がるにつれてアプリケーション側での記述量は減るが、内部の仕組みは複雑になる。

**パフォーマンスを考慮したクエリ生成**

単にSQLを生成するだけでなく、効率的なSQLを生成することも求められます。代表的な問題がN+1問題です。

たとえば「すべてのユーザーとその注文情報を取得する」という処理を考えます。素朴に実装すると、まずユーザー一覧を取得するクエリを1回発行し、次にユーザーごとに注文情報を取得するクエリをN回発行してしまいます。ユーザーが100人いれば101回のクエリが発行されることになります。JOINやサブクエリを使えば1回で済むところを、101回もデータベースに問い合わせるのは明らかに非効率です。

この問題はORMの自動化がもたらす副作用です。アプリケーションコードの見た目はシンプルですが、裏で大量のクエリが発行されている——という状況が発生しやすいのです。

**レイジーローディング**

関連するデータをいつ読み込むかという問題もあります。レイジーローディング（遅延読み込み）は、関連データを実際にアクセスされるまで読み込まない戦略です。一見効率的に思えますが、先述のN+1問題を引き起こしやすく、またデータベースへのコネクションが閉じた後にアクセスしようとしてエラーになるケースもあります。

逆にイーガーローディング（即時読み込み）は、最初からすべての関連データを読み込みます。使わないデータまで読み込む可能性がありますが、クエリ回数は予測しやすくなります。

どちらが適切かはユースケースによって異なり、ORMはこの選択をアプリケーション開発者に委ねることが多いです。

**論理削除（ソフトデリート）**

「データを削除する」という操作にも課題があります。物理的にレコードを削除するのではなく、削除フラグを立てて論理的に削除するパターンは実務で広く使われています。しかしこの場合、すべてのSELECTクエリに「削除されていないもの」という条件を暗黙的に付加する必要があります。ORMがこれを自動的に行うのか、開発者が毎回明示的に指定するのか——漏れがあれば削除済みのデータが表示されてしまうため、地味ですが重要な問題です。

#### 結果のオブジェクトへの変換

クエリの結果がデータベースから返ってきたら、それをアプリケーションが扱えるオブジェクトに変換する必要があります。これがまさにORMの「マッピング」の部分です。

単一テーブルの結果を単一のオブジェクトに変換するのは比較的簡単です。しかし、JOINを使って複数テーブルを結合した結果を、関連を持つ複数のオブジェクトに分解して組み立てるのは複雑な処理になります。さらに、1対多の関連がある場合、結果セットには重複する行が含まれるため、それらを適切にグルーピングしてオブジェクトのコレクションに変換する必要があります。

ORMの5段階の分類でいえば、レベル3（クエリと単純なオブジェクトのマッピング）では単一テーブルの結果しか扱えず、レベル4（関連ナビゲーション可能なオブジェクトのマッピング）以上になって初めて複数テーブルの結果を関連のあるオブジェクト群に変換できるようになります[^orm-level]。

#### アプリケーション側のパフォーマンス

データベースから取得してオブジェクトに変換したあとも、課題は残ります。

大量のデータを一度に取得してオブジェクトに変換すると、アプリケーションのメモリを圧迫します。たとえば数百万件のレコードをすべてオブジェクトに変換してリストに保持しようとすれば、メモリが枯渇する可能性があります。

これに対処するために、カーソルやストリーミングといった手法で少しずつデータを取得・処理する方法が使われます。しかしORMの基本的な設計思想は「結果をオブジェクトのコレクションとして返す」ことにあるため、大量データ処理とORMの相性は必ずしも良くありません。バッチ処理のような場面では、ORMを使わず直接SQLを書くほうが適切なケースもあります。

### 開発工程のなかで見る課題

次に、アプリケーション開発のライフサイクルの中で生じる課題を見ていきます。

#### マイグレーション管理

アプリケーションは変化しますが、データベースのスキーマも変化します。テーブルの追加、カラムの変更、インデックスの作成——こうしたスキーマの変更を管理するのがマイグレーションです。

厳密にはマイグレーション管理はORMの機能ではありません。しかし多くのORMがマイグレーション機能を内蔵しており、実際にはORMの一部として認識されていることが多いです。Ruby on RailsのActiveRecord MigrationsやDjangoのマイグレーション機能はその代表例です。

データベースのスキーマはアプリケーションコードよりも寿命が長く、かつ変更に弱い性質を持っています[^rdb-lifetime]。カラムを削除したら、そのデータは永久に失われます。テーブルの構造を変えたら、既存のデータを新しい構造に移行する必要があります。コードの変更は比較的やり直しがきくのに対し、データベースのスキーマ変更は慎重さが求められます。

[^rdb-lifetime]: データベースのスキーマはアプリケーションコードよりも長生きする傾向がある。アプリケーションは書き直されてもデータベースはそのまま使い続けられる、というケースは珍しくない。https://speakerdeck.com/soudai/table-design-that-is-resistant-to-changes?slide=39

#### 方言の吸収

リレーショナルデータベースにはSQLという共通言語がありますが、実際にはデータベース製品ごとに方言があります。MySQL、PostgreSQL、SQLite、Oracle、SQL Server——それぞれが独自の構文や関数を持っています。

たとえば文字列の結合ひとつとっても、MySQLでは`CONCAT(a, b)`、PostgreSQLでは`a || b`、SQL Serverでは`a + b`と書き方が異なります。日付関数、ページネーションの構文、自動採番の仕組みなども製品ごとに違います。

ORMはこうした方言の違いをアプリケーションから隠蔽します。同じアプリケーションコードで異なるデータベース製品を扱えるようにする——これはORMのクエリ生成機能が担っている重要な役割です。使うデータベースがMySQLからPostgreSQLに変わっても、理想的にはアプリケーションコードの変更なしに対応できることを目指しています。

#### 型の問題

データベースから返ってくるデータには、アプリケーション言語の型がついていません。データベースの`INTEGER`はアプリケーション言語の`int`にそのまま対応するとは限りませんし、`DATETIME`や`DECIMAL`のような型は言語ごとに対応する型が異なります。`NULL`の扱いも言語によってさまざまです。

ORMはデータベースの型とアプリケーション言語の型の対応関係を定義し、自動的に変換を行います。さらに近年では、TypeScriptのPrismaのように、スキーマ定義から型定義を自動生成して、コンパイル時に型安全性を保証するORMも登場しています。「データベースから取得したデータの型が実行時までわからない」という不安を、開発時に解消できるのは大きなメリットです。

#### テスト

データベースを使うアプリケーションのテストは、永遠のテーマです[^test]。

[^test]: データベースの改善にはテストが不可欠。クエリの改善とスキーマの改善の両方にテストが必要になる。

データベースは外部依存です。ユニットテストの文脈では、外部依存をモックに置き換えてテストすることが一般的ですが、データベースをモックにすると「SQLが正しく動くか」という最も重要な部分を検証できなくなります。かといって本物のデータベースを使うと、テストの実行速度が遅くなり、テスト間でデータが干渉する問題が生じます。

近年ではTestcontainersのような技術を使い、テストごとに使い捨てのデータベースコンテナを立ち上げるアプローチも広まっています。しかし「データベースレイヤーのテストをどうやるのが正解か」という問いに対する、決定的な答えはまだ出ていないのが現状です。

#### セキュリティ

SQLインジェクションは、Webアプリケーションにおける最も古典的かつ深刻なセキュリティ上の脅威のひとつです。ユーザーの入力値をそのままSQLに埋め込んでしまうと、意図しないSQLが実行される危険性があります。

ORMはクエリの組み立てを内部で行い、パラメータバインディング（プリペアドステートメント）を自動的に使用するため、SQLインジェクションのリスクを大幅に低減します。これはORMの重要な貢献のひとつであり、開発者がセキュリティを個別に意識しなくても安全なクエリが生成される仕組みになっています。

ただし、ORMが提供する「生SQL」機能を使う場合にはこの保護が効かないため、注意が必要です。

#### キャッシュ

同じクエリを何度も発行するのは非効率です。そこでORMの中にはクエリ結果のキャッシュ機能を持つものがあります。

Hibernateでは1次キャッシュ（セッション内キャッシュ）と2次キャッシュ（セッションをまたぐキャッシュ）の2段階のキャッシュ機構を持っています。1次キャッシュは同一トランザクション内で同じエンティティを複数回取得しても、データベースへの問い合わせは1回で済むようにします。2次キャッシュはアプリケーション全体でキャッシュを共有し、読み取りが多いデータの取得を高速化します。

しかしキャッシュには常にデータの鮮度（staleness）の問題がつきまといます。キャッシュされたデータが古くなっていないか、他のプロセスやサービスによって更新されていないか——キャッシュの無効化戦略は「コンピュータサイエンスにおける最も難しい問題のひとつ」と言われるほど厄介な問題です。

### インピーダンスミスマッチ——ORMの宿敵

ここまで個別の課題を見てきましたが、永続化レイヤーの抽象化にはもっと根深い構造的な問題があります。それが**インピーダンスミスマッチ**です。

#### インピーダンスミスマッチとは何か

インピーダンスミスマッチという言葉は、元々は電気電子分野の用語です[^impedance]。19世紀末に生まれた概念で、交流回路における電流の流れにくさを表します。回路Aの出力と回路Bの入力を接続する際に、両者のインピーダンス（電気抵抗のようなもの）に差が少ないと効率よく信号を受け渡しができます。逆に大きな差があると、信号が反射したり減衰したりして、うまく伝わりません。

[^impedance]: インピーダンスは19世紀末の交流回路理論で生まれた概念。回路間のインピーダンスの差が大きいと信号の受け渡し効率が落ちることから、パラダイム間の不整合を表す比喩として使われるようになった。

ソフトウェアの文脈では、**オブジェクト指向プログラミング（OOP）のパラダイムとリレーショナルデータベース（RDB）のパラダイムの間にある根本的な不整合**を指します。電気回路の比喩を借りれば、OOPという回路とRDBという回路のインピーダンスが大きくずれているために、両者の間でデータをうまく受け渡しできない、という問題です。

アプリケーション層のデータモデルと永続化層のデータモデルは、それぞれ異なる原理に基づいています。アプリケーション層はオブジェクトで表現され、頻繁に変化します。永続化層はリレーショナルモデルで表現され、安定性を重視します[^two-models]。この2つの世界をつなぐことが、ORMの根本的な使命であり、最大の困難でもあります。

[^two-models]: アプリケーション層と永続化層のデータモデルは本質的に異なる。永続化層のリレーショナルモデルは安定性を、アプリケーション層のオブジェクトモデルは柔軟性を重視する。OODBのようにどちらかに寄せる試みもあったが、主流にはなっていない。

#### 5つのパラダイムの違い

インピーダンスミスマッチは、具体的には次の5つの不整合として現れます。

**1. 粒度（Granularity）の不整合**

オブジェクトの世界では、データの粒度を自由に変えられます。たとえば「住所」を、都道府県・市区町村・番地・建物名といった複数のフィールドを持つ値オブジェクトとして表現できます。しかしリレーショナルデータベースでは、これを別テーブルにするか、同一テーブルの複数カラムにするかという選択を迫られ、オブジェクト側ほど柔軟に粒度を変えることができません。

オブジェクトは入れ子にしたり、グルーピングしたりといった構造化が自由自在ですが、テーブルはフラットな行と列の構造に縛られます。

**2. サブタイプ/継承（Subtypes/Inheritance）の不整合**

オブジェクト指向では継承や多態性（ポリモーフィズム）は基本的な概念です。たとえば「支払い方法」という親クラスを作り、「クレジットカード決済」「銀行振込」「コンビニ払い」をそのサブクラスとして表現するのは自然です。

しかしリレーショナルデータベースには継承の概念がありません。この構造をテーブルで表現するには、いくつかの戦略を選ぶ必要があります。全サブタイプを1つのテーブルにまとめる（Single Table Inheritance）、サブタイプごとにテーブルを分ける（Concrete Table Inheritance）、共通部分を親テーブルにして差分だけ子テーブルにする（Class Table Inheritance）——どの方法にも一長一短があり、「これで全て解決」という標準的なアプローチがないのが現状です。

**3. 同一性（Identity）の不整合**

リレーショナルデータベースでは、レコードの同一性は主キー（多くの場合はサロゲートキー）によって定義されます。`id = 1`のレコードと`id = 2`のレコードは別のものです。

一方、オブジェクトの世界には2種類の同一性があります。参照の同一性（同じメモリ上のオブジェクトか）と値の同一性（内容が等しいか）です。データベースから同じレコードを2回取得したとき、それは同一のオブジェクトなのか、それとも同じ内容を持つ別のオブジェクトなのか——この問題は、ORMにおけるアイデンティティマップパターンの必要性を生み出しています。

**4. 関連（Associations）の不整合**

オブジェクトの世界では、他のオブジェクトへの参照を持つことで関連を表現します。この参照には方向があり、単方向にも双方向にもできます。

リレーショナルデータベースでは、外部キーによって関連を表現します。外部キーは本質的に方向を持たず、JOINを使えばどちら方向からでもたどれます。また、多対多の関連はオブジェクトではコレクションの相互参照で表現できますが、RDBでは中間テーブルが必要になります。

**5. データナビゲーション（Data Navigation）の不整合**

オブジェクトの世界では、関連するデータに「たどって」アクセスするのが自然です。`user.orders[0].items[2].product.name`のように、オブジェクトのグラフを一歩ずつ歩いていきます。

リレーショナルデータベースでは、このようなナビゲーションは効率的ではありません。RDBの世界では、JOINを使って必要なデータを一度に取得するのが効率的です。オブジェクトのナビゲーションをそのままSQLに変換すると、先述のN+1問題が発生します。つまり、OOPとRDBではデータへのアクセス方法の設計思想そのものが異なるのです。

#### 「コンピュータ科学のベトナム」

2006年、ソフトウェアアーキテクトのTed Newardは、「The Vietnam of Computer Science」というブログ記事でORMを痛烈に批判しました[^vietnam]。

[^vietnam]: Ted Neward, "The Vietnam of Computer Science", 2006. ベトナム戦争のアナロジーを用いて、ORMプロジェクトが最初は成功するように見えるが、次第に泥沼にはまっていく様を描写した記事。

Newardはベトナム戦争のアナロジーを用いて、ORMの問題を描写しました。ベトナム戦争がアメリカにとって「最初は勝てると思っていたが、次第に泥沼にはまり、撤退もできず、莫大なコストを払い続けた」ものだったように、ORMプロジェクトも最初は生産性が上がり成功したように見えるが、プロジェクトが進むにつれてインピーダンスミスマッチの問題が噴出し、ORMの制約と格闘する時間が増え、最終的にはORMなしで書いたほうが速かったのではないか——という状態に陥ると主張したのです。

この記事はORM批判の古典として広く知られ、多くの議論を呼びました。Newardの主張はインピーダンスミスマッチが根本的に解決不可能であることを前提としており、その点においては正しいと言えます。OOPとRDBが異なるパラダイムである以上、完全な変換は原理的にできません。

**しかし、ORMはデファクトスタンダードです。**

批判があるにもかかわらず、2006年以降もORMは廃れるどころか、ますます普及しました。Ruby on Rails、Django、Laravel、Spring Boot——主要なWebフレームワークのほぼすべてがORMを標準装備しています。なぜでしょうか。

それは、ORMが解決している課題が、ORMが生み出す問題よりも大きいからです。コネクション管理、クエリ生成、型変換、セキュリティ——前節で見てきたこれらの課題に対して、ORMは実用的な解決策を提供しています。インピーダンスミスマッチを完全に解消することはできなくても、日常的なユースケースの大部分をカバーする実用性があるのです。

### この章のまとめ

この章では、永続化レイヤーの抽象化にまつわる課題を3つの視点から整理しました。

- **処理の流れ**：コネクション管理、クエリ生成（N+1問題、レイジーローディング、論理削除）、オブジェクト変換、アプリケーション側のパフォーマンス
- **開発工程**：マイグレーション管理、方言の吸収、型の問題、テスト、セキュリティ、キャッシュ
- **構造的問題**：インピーダンスミスマッチ（粒度・継承・同一性・関連・ナビゲーションの5つの不整合）

そしてORMはTed Newardに「コンピュータ科学のベトナム」とまで言われながらも、依然としてデファクトスタンダードであり続けています。

次の章では、ソフトウェア工学がこれらの課題にどう立ち向かってきたのか——ORMの具体的な仕組みと、いくつかの代表的な実装を見ていきます。


## これまでの解決策と、戦略としてのORM

前章までで、永続化レイヤー抽象化にまつわる課題を整理してきました。コネクション管理からクエリ生成、型変換、そしてインピーダンスミスマッチまで——課題は多岐にわたり、根深いものです。

この章では視点を変えて、**これらの課題に対してどのような解決策が試みられてきたのか**を見ていきます。ORMは突然現れたわけではありません。それ以前にもアプリケーションとデータベースの間を取り持つ技術は存在していました。それらを順に辿ることで、なぜORMが「選ばれた」のかが見えてきます。

### Embedded SQL——アプリケーションからSQLを呼び出す

最初の解決策は**Embedded SQL（埋め込みSQL）**でした。1970年代後半に考案され、1982年にIBMのDB2 V1.1とともに本格的な実装が整備されます[^esql]。

[^esql]: 1982年にDB2 V1.1とともにプリコンパイラー（DSNHPC）が開発された。

Embedded SQLの発想はシンプルです。プログラミング言語（当時は主にCOBOL）のソースコード内に、SQL文を直接埋め込みます。

```cobol
EXEC SQL
    SELECT EMP_NAME
    INTO :WS-EMPL-NAME
    FROM EMPLOYEE
    WHERE EMP_ID = :WS-EMPID
END-EXEC.
```

`:WS-EMPL-NAME`や`:WS-EMPID`は**ホスト変数**と呼ばれ、COBOLの変数をSQL文の中で参照するための仕組みです。COBOL側で定義した変数に、データベースから取得した値が直接格納されます。

しかし、COBOLのコンパイラーはSQL文を理解できません。そこで**プリコンパイル**という前処理が必要になります。プリコンパイラー（DSNHPC）は、ソースコードを解析して2つのアウトプットを生成します。

1. **修正されたCOBOLソースコード**——SQL文がコメントアウトされ、代わりにDB2のランタイムライブラリ（DSNHLI）への関数呼び出しに置き換えられる
2. **DBRM（Database Request Module）**——抽出されたSQL文のコレクション。プログラムとの関連付け情報やConsistency Token（整合性トークン）を含む

```
元のCOBOL+SQLプログラム
    ↓ プリコンパイル（DSNHPC）
修正されたCOBOLソース + DBRM
    ↓ コンパイル           ↓ BIND
実行モジュール          Plan/Package
    ↓                       ↓
         実行時に結合
```

つまり、「SQL文が埋め込まれたソースコード」は見かけ上のものであり、実際にはプリコンパイラーによって**SQL部分がまるごと抜き出され**、COBOLのコードとSQL文は別々のモジュールとして管理されます。実行時にはDSNHLI（High Level Interface）を通じて、COBOLプログラムとDB2が連携する仕組みです[^esql-runtime]。

[^esql-runtime]: 実行時には、DSNHADDRがホスト変数のメモリアドレスを設定し、DSNHLIがDB2との実際の通信を担当する。SQL実行結果はSQLCA（SQL Communication Area）を通じて状態コード（SQLCODE）として返される。

Embedded SQLは、**アプリケーションからSQLを呼び出す最初の体系的な手法**でした。前章の歴史でも触れたとおり、この技術によって初めて、プログラムの中からリレーショナルデータベースへの問い合わせが可能になったのです。

ただし、課題も明確でした。

- **プリコンパイルが必要**：ソースコードを変更するたびに、プリコンパイル→コンパイル→バインドという多段階の手順を踏む必要がある
- **特定のデータベースに依存**：DB2のEmbedded SQLはDB2専用であり、他のデータベースでは使えない
- **SQLが静的**：プリコンパイル時にSQL文が確定するため、実行時に動的にSQLを組み立てるのが困難

### CLI（Call Level Interface）——プリコンパイルからの解放

1980年代後半、Embedded SQLの課題を解決するために**CLI（Call Level Interface）**が登場しました[^cli]。

[^cli]: CLIは1980年代後半に登場。Embedded SQLのプリコンパイル方式に対する代替手段として開発された。

CLIの発想は、SQLの実行をプリコンパイルではなく**関数呼び出し**で行うというものです。

```c
SQLPrepare(stmt, "SELECT name FROM users WHERE id = ?", SQL_NTS);
SQLBindParameter(stmt, 1, SQL_PARAM_INPUT, SQL_C_LONG,
                 SQL_INTEGER, 0, 0, &userId, 0, NULL);
SQLExecute(stmt);
```

SQL文は文字列としてそのまま関数に渡されます。プリコンパイラーがソースコードからSQL文を抽出する必要はありません。コンパイルは通常のプログラムとまったく同じ手順で行えます。

CLIが解決したのは**ビルドプロセスの複雑さ**です。Embedded SQLではプリコンパイル→コンパイル→バインドという3段階が必要でしたが、CLIではコンパイルだけで済みます。また、SQL文が文字列として扱われるため、実行時に動的なクエリを組み立てることも容易になりました。

ただし、CLIにも限界がありました。各データベースベンダーが独自のCLI実装を提供していたため、**データベースごとに異なるAPIを使い分ける必要があった**のです。データベースを切り替えるには、アプリケーションの書き換えが避けられませんでした。

### ODBC——接続の標準化

1992年、Microsoftが中心となって**ODBC（Open Database Connectivity）**が策定されます[^odbc]。

[^odbc]: ODBCは1992年に策定。CLI（Call Level Interface）の標準化版として位置づけられる。

ODBCの核心は、データベースごとに異なる接続方法を**ドライバ**という仕組みで抽象化したことです。アプリケーションはODBCの共通APIを呼び出し、ODBCドライバマネージャが適切なデータベースドライバにリクエストを振り分けます。

```
アプリケーション
    ↓ ODBC共通API
ODBCドライバマネージャ
    ↓
データベース固有ドライバ（MySQL用 / PostgreSQL用 / Oracle用 ...）
    ↓
各データベース
```

`SQLPrepare`や`SQLExecute`といった関数名はCLIと同様ですが、その先の接続処理がドライバに委ねられます。アプリケーション開発者は、どのデータベースに接続するかを意識せずに同じAPIでクエリを発行できるようになりました。

ODBCが解決したのは**接続手法の標準化**です。前章で課題として挙げた「コネクション管理」に対する、当時としては画期的なソリューションでした。

ただし、ODBCが標準化したのはあくまで**接続とクエリの発行方法**です。SQLの方言——MySQLとPostgreSQLとOracleで異なる構文や関数——は吸収していません。`CONCAT(a, b)`か`a || b`かは、依然としてアプリケーション開発者が意識する必要がありました。クエリ結果の型変換もアプリケーション側の責任のままです。

### ここまでの流れを振り返る

Embedded SQL、CLI、ODBCという3つの技術を振り返ると、段階的に課題が解決されてきたことがわかります。

| 技術 | 時期 | 解決した課題 | 残った課題 |
|------|------|------------|-----------|
| Embedded SQL | 1970年代後半〜 | アプリケーションからのSQL呼び出し | プリコンパイル、DB依存、静的SQL |
| CLI | 1980年代後半〜 | プリコンパイルの廃止、動的SQL | DB固有のAPI |
| ODBC | 1992年〜 | 接続方法の標準化 | SQL方言、型変換、オブジェクト変換 |

しかし、これらの技術が解決したのは主に「アプリケーションとデータベースの**接続と通信**」の問題です。前章で見た課題のうち、コネクション管理やクエリの発行方法には対処できましたが、より根本的な問題——クエリ結果をどうオブジェクトに変換するか、SQLの方言をどう吸収するか、インピーダンスミスマッチをどう扱うか——には手をつけていません。

永続化レイヤーの抽象化には、接続の先にある「もう半分」が必要だったのです。

### ORM——2つの世界を橋渡しする

そして**ORM（Object-Relational Mapping）**が登場します。

ORMのアプローチは、それまでの技術とは根本的に異なるものでした。Embedded SQLからODBCまでの技術が「どうやってデータベースにアクセスするか」という**手段の問題**を解いていたのに対し、ORMは「オブジェクトとテーブルの間をどう変換するか」という**パラダイムの問題**に踏み込んだのです。

OOPの世界もRDBの世界もそのまま活かし、両者の間のマッピングを自動化する——これがORMの基本戦略です。最初のORMは1994年にリリースされたTopLink for Smalltalkでした[^toplink]。OOPの普及（1980年代後半〜1990年代）とRDBの定着（1980年代〜）が重なった時期に、まさに両者を橋渡しする技術として生まれたのです[^orm-oopdb]。

[^toplink]: TopLink for Smalltalkは1994年リリース。1996年にはTopLink for Javaが登場し、2002年にOracleに買収された。当初はエンタープライズ向けのライセンス製品として販売されていた。

[^orm-oopdb]: OOPの商用的な普及は1995年のWindows 95とJavaの登場が転機となった。RDBはそれ以前から企業システムの主力であった（Oracle2が1979年、IBM DB2が1983年）。両者が広く使われるようになった1990年代前半に、その間を取り持つ技術としてORMが生まれたのは必然だった。

ORMの登場は革命的でした。それまでの技術が主に「接続と通信」の問題を解決していたのに対し、ORMは以下の課題を一気に引き受けたのです。

- **クエリの自動生成**：アプリケーションコードからSQLを自動生成する。同じCRUD操作のSQLを何度も手書きする必要がなくなった
- **結果のオブジェクト変換**：クエリ結果を自動的にオブジェクトに変換する
- **型の変換**：データベースの型とプログラミング言語の型を自動的に対応づける
- **関連の管理**：テーブル間の外部キー関係を、オブジェクト間の参照として表現する
- **方言の吸収**：データベース製品ごとに異なるSQLの方言を、ORMの内部で吸収する

「しょうもないSQLを何度も書く」という生産性の問題を解決し、開発者がビジネスロジックに集中できる環境を作った——これがORMの最大の貢献です。

2000年代に入ると、IT業界にオープンソースソフトウェア（OSS）の波が押し寄せ、ORMも爆発的に普及します[^orm-oss]。TopLinkのようなエンタープライズ向けライセンス製品に対して、Hibernateが「Professional Open Source」の流れを作り、ORM業界の構造を変えました。

[^orm-oss]: 当初ORMはエンタープライズ向け製品（TopLink等）としてライセンス料金で販売されていた。Hibernateの登場により、Professional Open Sourceの流れが生まれた。

- 2004年：Hibernateリリース（現在も現役のOSS製ORM）
- 2005年：PHPでもORMが登場
- 2006年：Ruby on RailsとActiveRecordが登場

特に2006年のRuby on Railsは、WebフレームワークにORMを標準装備するスタイルを確立しました。以降、Django（Python）、Laravel（PHP）、Spring Boot（Java）と、主要なWebフレームワークのほぼすべてがORMを内蔵するようになり、ORMは「使うかどうか選ぶもの」から「最初から入っているもの」へと変わっていきます。

### リポジトリ層——アーキテクチャとしての抽象化

ORMとは異なるレイヤーで永続化の抽象化に取り組んだのが、ドメイン駆動設計（DDD）における**リポジトリパターン**です。

リポジトリパターンは、ドメインオブジェクトの永続化と取得を、あたかもインメモリのコレクションを操作するかのように行うためのインターフェースです。アプリケーション（ドメイン層）からは永続化の詳細が完全に隠蔽されます。

```
ドメイン層: UserRepository.findById(id)
    ↓ （インターフェース）
インフラストラクチャ層: ORM / 生SQL / NoSQL / etc.
```

リポジトリパターンの重要な点は、ORMの「代替」ではなく**「補完」**であるということです。リポジトリパターンは永続化を**アーキテクチャレベルで抽象化**し、ORMは**具体的な永続化手段**を提供します。リポジトリの実装としてORMを使うことは、実務では非常に一般的です。

ORMが「オブジェクトとテーブルの変換」という技術的な問題を解くのに対して、リポジトリパターンは「ドメインロジックと永続化の関心を分離する」という設計上の問題を解きます。両者は異なるレイヤーの課題に対応しており、組み合わせて使うことでより堅牢なアーキテクチャを構築できます。

### なぜORMが選ばれたのか

ここまで見てきた技術を改めて俯瞰してみましょう。

**Embedded SQL、CLI、ODBCは「接続の問題」を解決しました。** アプリケーションからデータベースにアクセスする方法を段階的に洗練させてきましたが、接続した先にある「オブジェクトとテーブルの変換」には手をつけていません。

**ORMは「接続の問題」と「変換の問題」の両方に対処しました。** インピーダンスミスマッチを完全に解消することはできないものの、日常的なユースケースの大部分をカバーする実用性を備えています。そして、OSSの普及とWebフレームワークとの統合により、デファクトスタンダードの地位を確立しました。

ORMが他の選択肢を圧倒した理由は、結局のところ**正統派だった**からです。OOPとRDBという2つの主流パラダイムをそのまま受け入れ、その間をつなぐ。どちらかのパラダイムを捨てるのではなく、両方を活かす。この現実的なアプローチが、産業界の広い支持を得たのです。

ただし、ORMが万能であるわけではありません。前章で見たインピーダンスミスマッチは原理的に解消できません。N+1問題やパフォーマンスの課題は、ORMを使う限りつきまとい続けます。そしてこれらの課題に対して、次世代のORMたちは新たなアプローチで挑んできました。

### この章のまとめと、以降の章の案内

この章では、永続化レイヤー抽象化の歴史のなかで試みられてきた解決策を辿り、ORMが「戦略として選ばれた理由」を見てきました。

- **Embedded SQL**（1970年代後半〜）で、アプリケーションから初めてSQLを呼び出せるようになった
- **CLI**（1980年代後半〜）で、プリコンパイルの制約から解放された
- **ODBC**（1992年〜）で、データベースへの接続方法が標準化された
- **ORM**（1990年代前半〜）で、オブジェクトとテーブルの変換が自動化された
- **リポジトリパターン**で、永続化がアーキテクチャレベルで抽象化された

次の章からは、いよいよORMそのものに深く切り込んでいきます。

- **ORMの概要**——ORMとは結局何をしているのか、その全体像を整理します
- **ORMの仕組み**——クエリビルダ、マッピング、キャッシュなど、ORMを構成するコンポーネントを見ていきます
- **ORMの選び方**——ActiveRecord型とDataMapper型の違い、プロジェクトに応じた選定基準を考えます
- **つくろう！　最高のORM**——ここまで学んだ知識を総動員して、最小構成のORMを実装します